// Copyright (c) 2021 Dennis Vis
//
// This software is released under the MIT License.
// https://opensource.org/licenses/MIT

package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"regexp"
	"strings"
)

const (
	templateFileNameMessageTypeSuffix = "parse"
	templateFileNameSuffix            = "_gen.go"
	generatedComment                  = "// Code generated by cmd/generate/generate.go, DO NOT EDIT\n\n"
)

var targetFileNamePattern = regexp.MustCompile(`mt([0-9]{3})(` + templateFileNameMessageTypeSuffix + `|)\.go`)

type target struct {
	sourceFileName string
	targetFileName string
	messageType    string
}

type targets []target

func (ts targets) String() string {
	s := ""
	for _, t := range ts {
		s += t.targetFileName + "\n"
	}
	return s
}

type template struct {
	fileName    string
	messageType string
	source      string
}

func fatal(msg string, err error) {
	fmt.Println(msg+": ", err)
	os.Exit(1)
}

func getTemplateString(filePath string) string {
	f, err := ioutil.ReadFile(filePath)
	if err != nil {
		fatal("could not open template file", err)
	}

	return string(f)
}

func collectTargetsAndTemplate(wd string) (targets, template) {
	files, err := ioutil.ReadDir(wd)
	if err != nil {
		fatal("could not open source files", err)
	}

	targets := make(targets, 0)
	tmpl := template{}

	for _, file := range files {
		matches := targetFileNamePattern.FindStringSubmatch(file.Name())

		if len(matches) > 0 {
			messageType := matches[1]

			if len(matches) == 3 && matches[2] == templateFileNameMessageTypeSuffix {
				tmpl.fileName = file.Name()
				tmpl.messageType = messageType
				tmpl.source = getTemplateString(wd + "/" + file.Name())
			} else {
				targetFileName := "mt" + messageType + templateFileNameMessageTypeSuffix + templateFileNameSuffix

				targets = append(targets, target{
					sourceFileName: file.Name(),
					targetFileName: targetFileName,
					messageType:    messageType,
				})
			}
		}
	}

	filteredTargets := make([]target, 0)
	for _, t := range targets {
		if t.messageType != tmpl.messageType {
			filteredTargets = append(filteredTargets, t)
		}
	}

	return filteredTargets, tmpl
}

func generateParserFile(wd string, tmpl template, t target) {
	source := strings.ReplaceAll(tmpl.source, tmpl.messageType, t.messageType)
	sourceWithComment := generatedComment + source
	sourceBts := []byte(sourceWithComment)

	err := ioutil.WriteFile(wd+"/"+t.targetFileName, sourceBts, 0644)
	if err != nil {
		fatal("could not write output file", err)
	}
}

// TODO - Generate test suite
func main() {
	wd, err := os.Getwd()
	if err != nil {
		fatal("could not read working directory", err)
	}

	targets, tmpl := collectTargetsAndTemplate(wd)

	fmt.Printf("Template file: %s\n", tmpl.fileName)
	fmt.Printf("Will generate:\n%s", targets)

	for _, t := range targets {
		generateParserFile(wd, tmpl, t)
	}

	fmt.Println("Done.")
}
